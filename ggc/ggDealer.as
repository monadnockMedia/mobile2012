package com.mobile.ggc {	import flash.system.System;	import flash.events.EventDispatcher;	import flash.events.Event;	import flash.utils.Dictionary;	public class ggDealer extends EventDispatcher{		var decks:ggDeck = new ggDeck;		var firstname:String; //This is a dummy variable		//var activePlayer:Player // need to keep track of active player here???		var _players:Object = {};		var matchScore:Object = {};		var roundScore:Object = {};		var votes:Object = {};		var thePlayers:ggPlayers;		var currentPlayerName:String = "";		var majority:Number;		public var playerList:Array = new Array();		var randomRange:Number = 20;		var randomLow:Number = 4;				//Config First		public function set config(cfg:XML):void		{			//set local config vars			majority = cfg.@majority;			firstname = cfg.firstname.toString(); //this is dummy var			decks.config = new XML(cfg.deck);  //setup decks depending on cfg xml			//allow for garbagecollection of XML after passing to decks.			System.disposeXML(cfg);			cfg = null;		}				//Players Second		public function set players(_p:ggPlayers):void		{						thePlayers = _p;			decks.players = thePlayers.toObject();			thePlayers.addEventListener(PlayerEvent.HIT_ME, dealTwo); //Players will request deal depending on game phase			for each (var p:ggPlayer in _p.thePlayers)			{				(p.team == "Populace")? null : playerList.push(p.team);							}			matchScore = initScores();			dispatchEvent(new DealerEvent(DealerEvent.SCORING, false, false, matchScore));		}				private function initScores():Object{			var _match = {};			var tmpScores:Array = new Array();			_match.total = 0;			for (var i:Number = 0; i < playerList.length; i++){				var thisScore:Number = Math.floor((Math.random()*randomRange)+randomLow);				tmpScores.push(thisScore);				_match.total += thisScore;			}						var j:Number = 0;			for each (var s:String in playerList){				var tmp:Object = {}				tmp.abs = tmpScores[j];				tmp.rel = tmpScores[j]/_match.total;				tmp.round = new Object;				tmp.round.change = 0;				_match[s] = tmp;				j++;			}						return _match;					}				//init Scores		/*public function set initScores(s:Object):void		{			matchScore = new Object();			matchScore.abs = new Object();			matchScore.rel = new Object();						var _scTMP = {};			_scTMP.abs={};			_scTMP.rel={};						var total:Number = 0;						for each (var o:Object in s){				total += o.points;			}						for each (var _o:Object in s){				_scTMP.abs[_o.team] = _o.points;				_scTMP.rel[_o.team] = _o.points/total;			}			matchScore = _scTMP;			dispatchEvent(new DealerEvent(DealerEvent.SCORING, false, false, _scTMP));					}*/						//Player wants two cards.		private function dealTwo(e:PlayerEvent):void		{			currentPlayerName = e.data;			var currentPlayer:basePlayer = thePlayers.playerRef(currentPlayerName);			currentPlayer.addEventListener(PlayerEvent.DECISION, playerChoice);			decks.addEventListener(DeckEvent.PULLED, cardPulled);			decks.drawTwo(currentPlayerName); //ask deck for cards		}								private function cardPulled(d:DeckEvent):void //deck returns cards.		{			decks.removeEventListener(DeckEvent.PULLED, cardPulled);			dispatchEvent(new DealerEvent(DealerEvent.CARDS_DEALT, false, false, d.cards))		}	//some player has chosen an issue to propose		public function playerChoice(e:PlayerEvent):void //player chooses card/action e.data is the *HAND* id of chosen card		{			var chosenID:Number = e.data;			var cP:basePlayer = e.currentTarget as basePlayer;			cP.removeEventListener(PlayerEvent.DECISION, playerChoice);									decks.discard(cP.team, chosenID);			decks.drop(cP.team, (chosenID+1)%2);			var uId:Number = cP.view[chosenID].uId;			dealIssue(uId);		}			//Players must be dealt issue for vote.		private function dealIssue(uId:Number):void		{						decks.addEventListener(DeckEvent.PULLED, issuePulled);			decks.drawIssue(uId); //ask deck for issue		}				private function issuePulled(d:DeckEvent):void		{									resetRound();						decks.removeEventListener(DeckEvent.PULLED, issuePulled);			dispatchEvent(new DealerEvent(DealerEvent.ISSUE_DEALT, true, false, d.cards))			thePlayers.addEventListener(PlayerEvent.VOTE, playerVote);		}				private function resetRound():void{			roundScore = new Dictionary(); //used to check and tabulate scores			votes.counted = 0;			votes.yea = 0;			votes.total =0;		}				//some Player has commited their vote on the issue		private function playerVote(vote:PlayerEvent):void		{			trace(vote);			var tmp:Object = {}			tmp.team = vote.data.team;			tmp.vote = vote.data.v;			tmp.points = vote.data.points;			if (roundScore[tmp.team]) {				trace("DUPE, something is definitely fucked")			}			else{				roundScore[tmp.team]=tmp;				votes.counted+=1;				votes.yea += tmp.vote; 							}						if (votes.counted == thePlayers.numPlayers-1){ //populace don't count!				//tally votes				(votes.yea >= majority) ? votePassed() : voteDenied(); //compare vote count to majority			}					}				private function votePassed():void{			for each (var o:Object in roundScore){				matchScore[o.team].abs += o.points;				matchScore[o.team].round.change = o.points;				matchScore[o.team].round.proposer = currentPlayerName;				matchScore.total += o.points;			}			for each (var p:String in playerList){				matchScore[p].rel = matchScore[p].abs/matchScore.total;			}						dispatchEvent(new DealerEvent(DealerEvent.SCORING, false, false, matchScore));					}												private function voteDenied():void{			dispatchEvent(new DealerEvent(DealerEvent.SCORING, false, false, matchScore));		}			}	}