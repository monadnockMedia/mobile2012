package com.mobile.ggc {	import flash.system.System;	import flash.events.EventDispatcher;	import flash.events.Event;	import flash.utils.Dictionary;	public class ggDealer extends EventDispatcher{		var decks:ggDeck = new ggDeck;		var firstname:String; //This is a dummy variable		//var activePlayer:Player // need to keep track of active player here???		var _players:Object = {};		var scores:Object = {};		var thePlayers:ggPlayers;		var currentPlayerName:String = "";		var majority:Number;						//Config First		public function set config(cfg:XML):void		{			//set local config vars			majority = cfg.@majority;			firstname = cfg.firstname.toString(); //this is dummy var			decks.config = new XML(cfg.deck);  //setup decks depending on cfg xml			//allow for garbagecollection of XML after passing to decks.			System.disposeXML(cfg);			cfg = null;		}				//Players Second		public function set players(_p:ggPlayers):void		{			scores.match = new Object();			scores.match.abs = new Object();			scores.match.rel = new Object();			thePlayers = _p;			decks.players = thePlayers.toObject();			thePlayers.addEventListener(PlayerEvent.HIT_ME, dealTwo); //Players will request deal depending on game phase			for each (var p:ggPlayer in _p.thePlayers)			{								scores.match.abs[p.team] = 0;			}		}								//Player wants two cards.		private function dealTwo(e:PlayerEvent):void		{			currentPlayerName = e.data;			var currentPlayer:basePlayer = thePlayers.playerRef(currentPlayerName);			currentPlayer.addEventListener(PlayerEvent.DECISION, playerChoice);			decks.addEventListener(DeckEvent.PULLED, cardPulled);			decks.drawTwo(currentPlayerName); //ask deck for cards		}								private function cardPulled(d:DeckEvent):void //deck returns cards.		{			decks.removeEventListener(DeckEvent.PULLED, cardPulled);			dispatchEvent(new DealerEvent(DealerEvent.CARDS_DEALT, false, false, d.cards))		}	//some player has chosen an issue to propose		public function playerChoice(e:PlayerEvent):void //player chooses card/action e.data is the *HAND* id of chosen card		{			var chosenID:Number = e.data;			var cP:basePlayer = e.currentTarget as basePlayer;			cP.removeEventListener(PlayerEvent.DECISION, playerChoice);									decks.discard(cP.team, chosenID);			decks.drop(cP.team, (chosenID+1)%2);			var uId:Number = cP.view[chosenID].uId;			dealIssue(uId);		}			//Players must be dealt issue for vote.		private function dealIssue(uId:Number):void		{						decks.addEventListener(DeckEvent.PULLED, issuePulled);			decks.drawIssue(uId); //ask deck for issue		}				private function issuePulled(d:DeckEvent):void		{									resetRound();						decks.removeEventListener(DeckEvent.PULLED, issuePulled);			dispatchEvent(new DealerEvent(DealerEvent.ISSUE_DEALT, true, false, d.cards))			thePlayers.addEventListener(PlayerEvent.VOTE, playerVote);		}				private function resetRound():void{			scores.round = new Dictionary(); //used to check and tabulate scores			scores.counted = 0;			scores.yea = 0;			scores.total =0;		}				//some Player has commited their vote on the issue		private function playerVote(vote:PlayerEvent):void		{			trace(vote);			var tmp:Object = {}			tmp.team = vote.data.team;			tmp.vote = vote.data.v;			tmp.points = vote.data.points;			if (scores.round[tmp.team]) {				trace("DUPE, something is definitely fucked")			}			else{				scores.round[tmp.team]=tmp;				scores.counted+=1;				scores.yea += tmp.vote; 				scores.total+=tmp.points;			}						if (scores.counted == thePlayers.numPlayers-1){ //populace don't count!				//tally votes				(scores.yea >= majority) ? votePassed() : voteDenied(); //compare vote count to majority			}					}				private function votePassed():void{			for each (var o:Object in scores.round){				scores.match.abs[o.team] += o.points;				scores.match.rel[o.team] = o.points/scores.total;			}						dispatchEvent(new DealerEvent(DealerEvent.SCORING, false, false, scores.match));					}		private function voteDenied():void{			dispatchEvent(new DealerEvent(DealerEvent.SCORING, false, false, scores.match));		}			}	}