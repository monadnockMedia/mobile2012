package com.mobile.ggc {	import com.nestor.tools.aUtil;	import flash.system.System;	import flash.events.EventDispatcher;	//Decks for each player keep track of player's hand, discard, and draw deck.	//Methods for dealer to draw	public class ggDeck extends EventDispatcher {		private var numCards:Number;				//cards per deck		private var table:String;					//name of DB table		private var path:String;					//relative path to db file		private var playerDecks:Object = {};		//contains arrays of id's by playername		private var util:aUtil = new aUtil;			//util to shuffle arrays		private var dbc:DBConnection = new DBConnection();			private var currentCards:Array; 			//buffer the pulled cards until a choice is made by player and relayed by dealer		private var currentPlayer:String;		//Set this first		public function set config(cfg:XML):void		{			numCards = Number(cfg.numCards.toString());			table = cfg.db.@table.toString();			path = cfg.db.@path.toString();						System.disposeXML(cfg);			cfg = null;						dbc.filePath = path;			openDB();		}				//Set this second		//takes an object containing names and IDs of all players, generates shuffled idDecks.		public function set players(p:Object):void		{			for each (var o:Object in p)			{				var playerName:String =  o.team;				var id:Number = o.id;				var deckSet:Object = {};									deckSet.name = playerName;					deckSet.id = id;					deckSet.deck = buildDeck(numCards); //Deck is just shuffled deck-id's					deckSet.discard = new Array();					deckSet.hand = new Array();										playerDecks[playerName] = deckSet;							}			deckSet = null;			dbc.players = p;		}				//Draw top card according to player name		public function drawTwo(p:String):void		{						checkDeck(p);			currentPlayer = p;			dbc.addEventListener(DBConnectionEvent.DB_RETURN, cardReturnHandler); //wait for DB to return cards			//remove top two card IDs from deck and place it in hand						//one card			var cardNum:Number = playerDecks[p].deck.shift();			playerDecks[p].hand.push(cardNum);			//and a second			cardNum = playerDecks[p].deck.shift();			playerDecks[p].hand.push(cardNum);			//call pull on dbc with array to return  Array.length cards			dbc.pullCard(table,p,playerDecks[p].hand); //and place them in player's hand.				}				//draw Issue according to uId		public function drawIssue(uId:Number):void		{			dbc.addEventListener(DBConnectionEvent.DB_RETURN, issueReturnHandler); //wait for DB to return cards			dbc.pullIssue(table,uId); //and place them in player's hand.		}												//place card *from hand* to bottom of deck		public function drop(p:String, card:Number):void		{			playerDecks[p].deck.push(playerDecks[p].hand.splice(playerDecks[p].hand.indexOf(card),1));		}				//move cards *from hand* to discard pile		public function discard(p:String, card:Number):void		{			playerDecks[p].discard.push(playerDecks[p].hand.splice(playerDecks[p].hand.indexOf(card),1));		}				private function checkDeck(p:String):void		{			(playerDecks[p].deck.length > 1) ? null : resetDeck(p) ;		}						//called when DB returns pulled card		private function cardReturnHandler(d:DBConnectionEvent):void		{			dbc.removeEventListener(DBConnectionEvent.DB_RETURN, cardReturnHandler); //wait for DB to return cards			//wrapped function buildChoiceCards parses db Object into an array of View objects			dispatchEvent(new DeckEvent(DeckEvent.PULLED, false, false, buildChoiceCards(d.data)));		}				//called when DB returns pulled issues		private function issueReturnHandler(d:DBConnectionEvent):void		{			dbc.removeEventListener(DBConnectionEvent.DB_RETURN, issueReturnHandler); //wait for DB to return cards			//wrapped function buildChoiceCards parses db Object into an array of View objects			dispatchEvent(new DeckEvent(DeckEvent.PULLED, false, false, buildIssueCards(d.data)));		}				private function buildChoiceCards(d:*):Object		{			//store current cards in order to create various views when player choice is made.			currentCards = d;			var i:Number = 0;			//create views containing only necessary info on two cards drawn.			var ret:Object = new Object();			for each (var o:Object in currentCards)			{				var card:Object = {};				card.Body = o.Body;				card.Topic = o.Topic;				card.DeckId = o.DeckId;				card.DeckIndex = o.DeckIndex;				card.uId = o.uId;								ret[i] =card ;								i++;			}			ret.cardType = "choice";			return ret;					}				private function buildIssueCards(d:*):Object		{			//store current cards in order to create various views when player choice is made.			currentCards = d;						//create views for each player			var ret:Object = new Object();			for each (var p:Object in playerDecks)			{				var team:String = p.name;				var view:Object = new Object();				var teamPtName = team.slice(0,3)+"Pt"; //This sucks				view.Topic = d[0].Topic;				view.proposer = d[0].DeckName;				view.Body = d[0][team];				view.cardType = "issue";				view.points = d[0][teamPtName];				ret[team] = view;				trace("");			}						return ret;					}						//Builds a stack of ids, which can be treated as a "deck" to reference the DB.		private function buildDeck(n:Number):Array		{			var deck:Array = new Array;			//Deck must be 1-indexed!!			for (var i:Number = 1; i<=n; i++)			{				deck.push(i);			}			deck = shuffleDeck(deck);			return deck;		}		//resets deck, don't use in middle of turn.		private function resetDeck(p:String):void{			playerDecks[p].deck = buildDeck(numCards);			playerDecks[p].discard = new Array();			playerDecks[p].hand = new Array();		}						public function openDB() {						dbc.addEventListener(DBConnectionEvent.DB_OPEN, dbOpenHandler);			dbc.openConn()		}				private function dbOpenHandler(d:DBConnectionEvent):void		{			dbc.removeEventListener(DBConnectionEvent.DB_OPEN, dbOpenHandler);		}		//shuffle the deck		private function shuffleDeck(a:Array):Array		{			return util.shuffle(a);		}	}	}